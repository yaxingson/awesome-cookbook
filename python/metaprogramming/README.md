# Table of Contents

## Putting a Wrapper Around a Function

## Preserving Function Metadata When Writing Decorators

## Unwrapping a Decorator

## Defining a Decorator That Takes Arguments

## Defining a Decorator with User Adjustable Attributes

## Defining a Decorator That Takes an Optional Argument

## Enforcing Type Checking on a Function Using a Decorator

## Defining Decorators As Part of a Class

## Defining Decorators As Classes

## Applying Decorators to Class and Static Methods

## Writing Decorators That Add Arguments to Wrapped Functions

## Using Decorators to Patch Class Definitions

## Using a Metaclass to Control Instance Creation

## Capturing Class Attribute Definition Order

## Defining a Metaclass That Takes Optional Arguments

## Enforcing an Argument Signature on *args and **kwargs

## Enforcing Coding Conventions in Classes

## Defining Classes Programmatically

## Initializing Class Members at Definition Time

## Implementing Multiple Dispatch with Function Annotations

## Avoiding Repetitive Property Methods

## Defining Context Managers the Easy Way

## Executing Code with Local Side Effects

## Parsing and Analyzing Python Source

## Disassembling Python Byte Code
