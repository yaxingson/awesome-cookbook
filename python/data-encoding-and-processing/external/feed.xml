<?xml version="1.0" ?>
<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
  <channel>
    <title>Anthony Fu</title>
    <link>https://antfu.me/</link>
    <description lang="zh-CN">Anthony Fu' Blog</description>
    <lastBuildDate>Tue, 18 Feb 2025 10:08:29 GMT</lastBuildDate>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <generator>https://github.com/jpmonette/feed</generator>
    <image>
      <title>Anthony Fu</title>
      <url>https://antfu.me/avatar.png</url>
      <link>https://antfu.me/</link>
    </image>
    <copyright>CC BY-NC-SA 4.0 2021 © Anthony Fu</copyright>
    <atom:link href="https://antfu.me/feed.xml" rel="self" type="application/rss+xml"/>
    <item>
      <title>
        <![CDATA[ Move on to ESM-only ]]>
      </title>
      <link>https://antfu.me/posts/move-on-to-esm-only</link>
      <guid>https://antfu.me/posts/move-on-to-esm-only</guid>
      <pubDate>Wed, 05 Feb 2025 00:00:00 GMT</pubDate>
      <description>
        <![CDATA[ Let's move on to ESM-only ]]>
      </description>
      <content:encoded>
        <![CDATA[ <p>[[toc]]</p> <p>Three years ago, I wrote a post about <a href="/posts/publish-esm-and-cjs">shipping ESM &amp; CJS in a single package</a>, advocating for dual CJS/ESM formats to ease user migration and trying to make the best of both worlds. Back then, I didn't fully agree with <a href="https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c">aggressively shipping ESM-only</a>, as I considered the ecosystem wasn't ready, especially since the push was mostly from low-level libraries. Over time, as tools and the ecosystem have evolved, my perspective has gradually shifted towards more and more on adopting ESM-only.</p> <p>As of 2025, a decade has passed since ESM was first introduced in 2015. Modern tools and libraries have increasingly adopted ESM as the primary module format. According to {@wooorm}'s <a href="https://github.com/wooorm/npm-esm-vs-cjs">script</a>, the packages that ships ESM on npm in 2021 was <strong>7.8%</strong>, and by the end of 2024, it had reached <a href="https://github.com/wooorm/npm-esm-vs-cjs"><strong>25.8%</strong></a>. Although a significant portion of packages still use CJS, the trend clearly shows a good shift towards ESM.</p> <figure> <img src="https://antfu.me/images/npm-esm-vs-cjs-2024.svg" dark:filter-invert /> <figcaption text-center>ESM adoption over time, generated by the <code>npm-esm-vs-cjs</code> script. Last updated at 2024-11-27</figcaption> </figure> <p>Here in this post, I'd like to share my thoughts on the current state of the ecosystem and why I believe it's time to move on to ESM-only.</p> <h2>The Toolings are Ready</h2> <h3>Modern Tools</h3> <p>With the rise of <a href="https://vite.dev">Vite</a> as a popular modern frontend build tool, many meta-frameworks like <a href="https://nuxtjs.org">Nuxt</a>, <a href="https://kit.svelte.dev">SvelteKit</a>, <a href="https://astro.build">Astro</a>, <a href="https://solidstart.dev">SolidStart</a>, <a href="https://remix.run">Remix</a>, <a href="https://storybook.js.org">Storybook</a>, <a href="https://redwoodjs.com">Redwood</a>, and many others are all built on top of Vite nowadays, that <strong>treating ESM as a first-class citizen</strong>.</p> <p>As a complement, we have also testing library <a href="https://vitest.dev">Vitest</a>, which was designed for ESM from the day one with powerful module mocking capability and efficient fine-grain caching support.</p> <p>CLI tools like <a href="https://github.com/privatenumber/tsx"><code>tsx</code></a> and <a href="https://github.com/unjs/jiti"><code>jiti</code></a> offer a seamless experience for running TypeScript and ESM code without requiring additional configuration. This simplifies the development process and reduces the overhead associated with setting up a project to use ESM.</p> <p>Other tools, for example, <a href="https://eslint.org">ESLint</a>, in the recent v9.0, introduced a new flat config system that enables native ESM support with <code>eslint.config.mjs</code>, even in CJS projects.</p> <h3>Top-Down &amp; Bottom-Up</h3> <p>Back in 2021, when {@sindresorhus} first started migrating all his packages to ESM-only, for example, <code>find-up</code> and <code>execa</code>, it was a bold move. I consider this move as a <strong>bottom-up</strong> approach, as the packages that rather low-level and many their dependents are not ready for ESM yet. I was worried that this would force those dependents to stay on the old version of the packages, which might result in the ecosystem being fragmented. (As of today, I actually appreciate that move bringing us quite a lot of high-quality ESM packages, regardless that the process wasn't super smooth).</p> <p>It's way easier for an ESM or Dual formats package to depend on CJS packages, but not the other way around. In terms of smooth adoption, I believe the <strong>top-down</strong> approach is more effective in pushing the ecosystem forward. With the support of high-level frameworks and tools from top-down, it's no longer a significant obstacle to use ESM-only packages. The remaining challenges in terms of ESM adoption primarily lie with package authors needing to migrate and ship their code in ESM format.</p> <h3>Requiring ESM in Node.js</h3> <p>The <a href="https://github.com/nodejs/node/pull/51977">capability to <code>require()</code> ESM modules</a> in Node.js, initiated by {@joyeecheung}, marks an <strong>incredible milestone</strong>. This feature allows packages to be published as ESM-only while still being consumable by CJS codebases with minimal modifications. It helps avoid the async infection (also known as <a href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">Red Functions</a>) introduced by dynamic <code>import()</code> ESM, which can be pretty hard, if not impossible in some cases, to migrate and adapt.</p> <p>This feature was recently <a href="https://github.com/nodejs/node/pull/55085">unflagged</a> and <a href="https://github.com/nodejs/node/pull/55217">backported to Node.js v22</a> (<a href="https://github.com/nodejs/node/pull/56927">and soon v20</a>), which means it should be available to many developers already. Consider the <a href="#top-down--bottom-up">top-down or bottom-up</a> metaphor, this feature actually makes it possible to start ESM migration also from <strong>middle-out</strong>, as it allows import chains like <code>ESM → CJS → ESM → CJS</code> to work seamlessly.</p> <p>For more details on the progress and discussions around this feature, keep track on <a href="https://github.com/nodejs/node/issues/52697">this issue</a>.</p> <h2>The Troubles with Dual Formats</h2> <p>While dual CJS/ESM packages have been a quite helpful transition mechanism, they come with their own set of challenges. Maintaining two separate formats can be cumbersome and error-prone, especially when dealing with complex codebases. Here are some of the issues that arise when maintaining dual formats:</p> <h3>Interop Issues</h3> <p>Fundamentally, CJS and ESM are different module systems with distinct design philosophies. Although Node.js has made it possible to import CJS modules in ESM, dynamically import ESM in CJS, and even <code>require()</code> ESM modules, there are still many tricky cases that can lead to interop issues.</p> <p>One key difference is that CJS typically uses a single <code>module.exports</code> object, while ESM supports both default and named exports. When authoring code in ESM and transpiling to CJS, handling exports can be particularly challenging, especially when the exported value is a non-object, such as a function or a class. Additionally, to make the types correct, we also need to introduce further complications with <code>.d.mts</code> and <code>.d.cts</code> declaration files. And so on...</p> <p>As I am trying to explain this problem deeper, I found that I actually wish you didn't even need to be bothered with this problem at all. It's frankly too complicated and frustrating. If you are just a user of packages, let alone the package authors to worry about that. This is one of the reasons I advocate for the entire ecosystem to transition to ESM, to leave these problems behind and spare everyone from this unnecessary hassle.</p> <h3>Dependency Resolution</h3> <p>When a package has both CJS and ESM formats, the resolution of dependencies can become convoluted. For example, if a package depends on another package that only ships ESM, the consumer must ensure that the ESM version is used. This can lead to version conflicts and dependency resolution issues, especially when dealing with transitive dependencies.</p> <p>Also for packages that are designed to used with singleton pattern, this might introduce multiple copies of the same package and cause unexpected behaviors.</p> <h3>Package Size</h3> <p>Shipping dual formats essentially doubles the package size, as both CJS and ESM bundles need to be included. While a few extra kilobytes might not seem significant for a single package, the overhead can quickly add up in projects with hundreds of dependencies, leading to the infamous node_modules bloat. Therefore, package authors should keep an eye on their package size. Moving to ESM-only is a way to optimize it, especially if the package doesn't have strong requirements on CJS.</p> <h2>When Should We Move to ESM-only?</h2> <p>This post does not intend to diminish the value of dual-format publishing. Instead, I want to encourage evaluating the current state of the ecosystem and the potential benefits of transitioning to ESM-only.</p> <p>There are several factors to consider when deciding whether to move to ESM-only:</p> <h3>New Packages</h3> <p>I strongly recommend that <strong>all new packages</strong> be released as ESM-only, as there are no legacy dependencies to consider. New adopters are likely already using a modern, ESM-ready stack, there being ESM-only should not affect the adoption. Additionally, maintaining a single module system simplifies development, reduces maintenance overhead, and ensures that your package benefits from future ecosystem advancements.</p> <h3>Browser-targeted Packages</h3> <p>If a package is primarily targeted for the browser, it makes total sense to ship ESM-only. In most cases, browser packages go through a bundler, where ESM provides significant advantages in static analysis and tree-shaking. This leads to smaller and more optimized bundles, which would also improve loading performance and reduce bandwidth consumption for end users.</p> <h3>Standalone CLI</h3> <p>For a standalone CLI tool, it's no difference to end users whether it's ESM or CJS. However, using ESM would enable your dependencies to also be ESM, facilitating the ecosystem's transition to ESM from a <a href="#top-down--bottom-up">top-down approach</a>.</p> <h3>Node.js Support</h3> <p>If a package is targeting the evergreen Node.js versions, it's a good time to consider ESM-only, especially with the recent <a href="#requiring-esm-in-nodejs"><code>require(ESM)</code> support</a>.</p> <h3>Know Your Consumers</h3> <p>If a package already has certain users, it's essential to understand the dependents' status and requirements. For example, for an ESLint plugin/utils that requires ESLint v9, while ESLint v9's new config system supports ESM natively even in CJS projects, there is no blocker for it to be ESM-only.</p> <p>Definitely, there are different factors to consider for different projects. But in general, I believe the ecosystem is ready for more packages to move to ESM-only, and it's a good time to evaluate the benefits and potential challenges of transitioning.</p> <h2>How Far We Are?</h2> <p>The transition to ESM is a gradual process that requires collaboration and effort from the entire ecosystem. Which I believe we are on a good track moving forward.</p> <p>To improve the transparency and visibility of the ESM adoption, I recently built a visualized tool called <a href="https://github.com/antfu/node-modules-inspector">Node Modules Inspector</a> for analyzing your packages's dependencies. It provides insights into the ESM adoption status of your dependencies and helps identify potential issues when migrating to ESM.</p> <p>Here are some screenshots of the tool to give you a quick impression:</p> <figure> <img src="/images/node-modules-inspector-1.png" scale-110 /> <figcaption text-center>Node Modules Inspector - Overview</figcaption> </figure> <figure> <img src="/images/node-modules-inspector-2.png" scale-110 /> <figcaption text-center>Node Modules Inspector - Dependency Graph</figcaption> </figure> <figure> <img src="/images/node-modules-inspector-3.png" scale-110 /> <figcaption text-center>Node Modules Inspector - Reports like ESM Adoptions and Duplicated Packages</figcaption> </figure> <p>This tool is still in its early stages, but I hope it will be a valuable resource for package authors and maintainers to track the ESM adoption progress of their dependencies and make informed decisions about transitioning to ESM-only.</p> <p>To learn more about how to use it and inspect your projects, check the repository <GitHubLink repo="antfu/node-modules-inspector" />.</p> <h2>Moving Forward</h2> <p>I am planning to gradually transition the packages I maintain to ESM-only and take a closer look at the dependencies we rely on. We also have plenty of exciting ideas for the Node Modules Inspector, aiming to provide more useful insights and help find the best path forward.</p> <p>I look forward to a more portable, resilient, and optimized JavaScript/TypeScript ecosystem.</p> <p>I hope this post has shed some light on the benefits of moving to ESM-only and the current state of the ecosystem. If you have any thoughts or questions, feel free to reach out using the links below. Thank you for reading!</p> ]]>
      </content:encoded>
      <author>hi@antfu.me (Anthony Fu)</author>
    </item>
    <item>
      <title>
      <![CDATA[ Epoch Semantic Versioning ]]>
      </title>
      <link>https://antfu.me/posts/epoch-semver</link>
      <guid>https://antfu.me/posts/epoch-semver</guid>
      <pubDate>Tue, 07 Jan 2025 12:00:00 GMT</pubDate>
      <description>
      <![CDATA[ Proposal for an extended Semantic Versioning called Epoch SemVer to provide more granular versioning information to users. ]]>
      </description>
      <content:encoded>
      <![CDATA[ <p>If you've been following my work in open source, you might have noticed that I have a tendency to stick with zero-major versioning, like <code>v0.x.x</code>. For instance, as of writing this post, the latest version of UnoCSS is <a href="https://github.com/unocss/unocss/releases/tag/v0.65.3"><code>v0.65.3</code></a>, Slidev is <a href="https://github.com/slidevjs/slidev/releases/tag/v0.50.0"><code>v0.50.0</code></a>, and <code>unplugin-vue-components</code> is <a href="https://github.com/unplugin/unplugin-vue-components/releases/tag/v0.28.0"><code>v0.28.0</code></a>. Other projects, such as React Native is on <a href="https://github.com/facebook/react-native/releases/tag/v0.76.5"><code>v0.76.5</code></a>, and sharp is on <a href="https://github.com/lovell/sharp/releases/tag/v0.33.5"><code>v0.33.5</code></a>, also follow this pattern.</p> <p>People often assume that a zero-major version indicates that the software is not ready for production. However, all of the projects mentioned here are quite stable and production-ready, used by millions of projects.</p> <p><strong>Why?</strong> - I bet that's your question reading this.</p> <h2>Versioning</h2> <p>Version numbers act as snapshots of our codebase, helping us communicate changes effectively. For instance, we can say &quot;it works in v1.3.2, but not in v1.3.3, there might be a regression.&quot; This makes it easier for maintainers to locate bugs by comparing the differences between these versions. A version is essentially a marker, a seal of the codebase at a specific point in time.</p> <p>However, code is complex, and every change involves trade-offs. Describing how a change affects the code can be tricky even with natural language. A version number alone can't capture all the nuances of a release. That's why we have changelogs, release notes, and commit messages to provide more context.</p> <p>I see versioning as a way to communicate changes to users — a <strong>contract</strong> between the library maintainers and the users to ensure compatibility and stability during upgrades. As a user, you can't always tell what's changed between <code>v2.3.4</code> and <code>v2.3.5</code> without checking the changelog. But by looking at the numbers, you can infer that it's a patch release meant to fix bugs, which <strong>should</strong> be safe to upgrade. This ability to understand changes just by looking at the version number is possible because both the library maintainer and the users agree on the versioning scheme.</p> <p>Since versioning is only a contract, and could be interpreted differently to each specific project, you shouldn't blindly trust it. It serves as an indication to help you decide when to take a closer look at the changelog and be cautious about upgrading. But it's not a guarantee that everything will work as expected, as every change might introduce behavior changes, whether it's intended or not.</p> <h2>Semantic Versioning</h2> <p>In the JavaScript ecosystem, especially for packages published on npm, we follow a convention known as <a href="https://semver.org/">Semantic Versioning</a>, or SemVer for short. A SemVer version number consists of three parts: <code>MAJOR.MINOR.PATCH</code>. The rules are straightforward:</p> <ul> <li><span font-bold font-mono text-amber>MAJOR</span>: Increment when you make incompatible API changes.</li> <li><span font-bold font-mono text-lime>MINOR</span>: Increment when you add functionality in a backwards-compatible manner.</li> <li><span font-bold font-mono text-blue>PATCH</span>: Increment when you make backwards-compatible bug fixes.</li> </ul> <p>Package managers we use, like <code>npm</code>, <code>pnpm</code>, and <code>yarn</code>, all operate under the assumption that every package on npm adheres to SemVer. When you or a package specifies a dependency with a version range, such as <code>^1.2.3</code>, it indicates that you are comfortable with upgrading to any version that shares the same major version (<code>1.x.x</code>). In these scenarios, package managers will automatically determine the best version to install based on what is most suitable for your specific project.</p> <p>This convention works well technically. If a package releases a new major version <code>v2.0.0</code>, your package manager won't install it if your specified range is <code>^1.2.3</code>. This prevents unexpected breaking changes from affecting your project until you manually update the version range.</p> <p>However, humans perceive numbers on a logarithmic scale. We tend to see <code>v2.0</code> to <code>v3.0</code> as a huge, groundbreaking change, while <code>v125.0</code> to <code>v126.0</code> seems a lot more trivial, even though both indicate incompatible API changes in SemVer. This perception can make maintainers hesitant to bump the major version for minor breaking changes, leading to the accumulation of many breaking changes in a single major release, making upgrades harder for users. Conversely, with something like <code>v125.0</code>, it becomes difficult to convey the significance of a major change, as the jump to <code>v126.0</code> appears minor.</p> <blockquote> <p>{@TkDodo|Dominik Dorfmeister} had <a href="https://tkdodo.eu/blog/react-query-api-design-lessons-learned">a great talk about API Design</a>, which mentions an interesting inequality that descripting this: <a href="https://tkdodo.eu/blog/react-query-api-design-lessons-learned?page=30">&quot;Breaking Changes !== Marketing Event&quot;</a></p> </blockquote> <h2>Progressive</h2> <p>I am a strong believer in the principle of progressiveness. Rather than making a giant leap to a significantly higher stage all at once, progressiveness allows users to adopt changes gradually at their own pace. It provides opportunities to pause and assess, making it easier to understand the impact of each change.</p> <figure text-center> <img src="https://antfu.me/images/epoch-semver-progressive-1.png" alt="Progressive as Stairs" border="~ base rounded-xl"> <figcaption>Progressive as Stairs - a screenshot of my talk <a italic font-serif href="/talks#the-progressive-path" target="_blank">The Progressive Path</a></figcaption> </figure> <p>I believe we should apply the same principle to versioning. Instead of treating a major version as a massive overhaul, we can break it down into smaller, more manageable updates. For example, rather than releasing <code>v2.0.0</code> with 10 breaking changes from <code>v1.x</code>, we could distribute these changes across several smaller major releases. This way, we might release <code>v2.0</code> with 2 breaking changes, followed by <code>v3.0</code> with 1 breaking change, and so on. This approach makes it easier for users to adopt changes gradually and reduces the risk of overwhelming them with too many changes at once.</p> <figure text-center> <img src="/images/epoch-semver-progressive-2.png" alt="Progressive on Breaking Changes" border="~ base rounded-xl"> <figcaption>Progressive on Breaking Changes - a screenshot of my talk <a italic font-serif href="/talks#the-progressive-path" target="_blank">The Progressive Path</a></figcaption> </figure> <h2>Leading Zero Major Versioning</h2> <p>The reason I've stuck with <code>v0.x.x</code> is my own unconventional approach to versioning. I prefer to introduce necessary and minor breaking changes early on, making upgrades easier, without causing alarm that typically comes with major version jumps like <code>v2</code> to <code>v3</code>. Some changes might be &quot;technically&quot; breaking but don't impact 99.9% of users in practice. (Breaking changes are relative. Even a bug fix can be breaking for those relying on the previous behavior, but that's another topic for discussion :P).</p> <p>There's a special rule in SemVer that states <strong>when the leading major version is <code>0</code>, every minor version bump is considered breaking</strong>. I am kind of <strong>abusing</strong> that rule to workaround the limitation of SemVer. With zero-major versioning, we are effectively abandoning the first number, and merge <code>MINOR</code> and <code>PATCH</code> into a single number (thanks to <a href="https://x.com/ssalbdivad">David Blass</a> for pointing <a href="https://x.com/ssalbdivad/status/1876614090623431116">this</a> out):</p> <div py4> <code important="text-xl text-gray"><span line-through>ZERO</span>.<span font-bold text-amber>MAJOR</span>.{<span font-bold text-lime>MINOR</span> + <span font-bold text-blue>PATCH</span>}</code> </div> <blockquote> <p>Of course, zero-major versioning is not the only solution to be progressive. We can see that tools like <a href="https://nodejs.org/en">Node.js</a>, <a href="https://vite.dev/">Vite</a>, <a href="https://vitest.dev/">Vitest</a> are rolling out major versions in consistent intervals, with a minimal set of breaking changes in each release that are easy to adopt. It would require a lot of effort and extra attentions. Kudos to them!</p> </blockquote> <p>I have to admit that sticking to <strong>zero-major versioning isn't the best practice.</strong> While I aimed for more granular versioning to improve communication, using zero-major versioning has actually limited the ability to convey changes effectively. In reality, I've been wasting a valuable part of the versioning scheme due to my peculiar insistence.</p> <p>Thus, here, I am proposing to change.</p> <h2>Epoch Semantic Versioning</h2> <p><a href="https://x.com/antfu7/status/1679184417930059777">In an ideal world, I would wish SemVer to have 4 numbers: <code>EPOCH.MAJOR.MINOR.PATCH</code></a>. The <code>EPOCH</code> version is for those big announcements, while <code>MAJOR</code> is for technical incompatible API changes that might not be significant. This way, we can have a more granular way to communicate changes. Similarly, we also have <a href="https://github.com/romversioning/romver">Romantic Versioning that propose <code>HUMAN.MAJOR.MINOR</code></a>. The creator of SemVer, <a href="https://tom.preston-werner.com/">Tom Preston-Werner</a> also <a href="https://tom.preston-werner.com/2022/05/23/major-version-numbers-are-not-sacred">mentioned similar concerns and solutions in this blog post</a>. (thanks to <a href="https://x.com/sebastienlorber">Sébastien Lorber</a> for pointing <a href="https://x.com/sebastienlorber/status/1879127128530460856">this</a> out).</p> <p>But, of course, it's too late for the entire ecosystem to adopt a new versioning scheme.</p> <p>If we can't change SemVer, maybe we can at least extend it. I am proposing a new versioning scheme called <strong>🗿 Epoch Semantic Versioning</strong>, or Epoch SemVer for short. It's built on top of the structure of <code>MAJOR.MINOR.PATCH</code>, extend the first number to be the combination of <code>EPOCH</code> and <code>MAJOR</code>. To put a difference between them, we use a fourth digit to represent <code>EPOCH</code>, which gives <code>MAJOR</code> a range from 0 to 999. This way, it follows the exact same rules as SemVer <strong>without requiring any existing tools to change, but provides more granular information to users</strong>.</p> <blockquote> <p>The name &quot;Epoch&quot; is inspired by <a href="https://manpages.debian.org/stretch/dpkg-dev/deb-version.5.en.html">Debian's versioning scheme</a>.</p> </blockquote> <p>The format is as follows:</p> <div py4> <code important="text-xl text-gray">{<span font-bold text-violet>EPOCH</span> * 1000 + <span font-bold text-amber>MAJOR</span>}.<span font-bold text-lime>MINOR</span>.<span font-bold text-blue>PATCH</span></code> </div> <ul> <li><span font-bold font-mono text-violet>EPOCH</span>: Increment when you make significant or groundbreaking changes.</li> <li><span font-bold font-mono text-amber>MAJOR</span>: Increment when you make minor incompatible API changes.</li> <li><span font-bold font-mono text-lime>MINOR</span>: Increment when you add functionality in a backwards-compatible manner.</li> <li><span font-bold font-mono text-blue>PATCH</span>: Increment when you make backwards-compatible bug fixes.</li> </ul> <blockquote> <p>I previously proposed to have the EPOCH multiplier to be <code>100</code>, but according to the community feedback, it seems that <code>1000</code> is a more popular choices as it give more room for the <code>MAJOR</code> version and a bit more distinguision between the numbers. The multiplier is not a strict rule, feel free to adjust it based on your needs.</p> </blockquote> <p>For example, UnoCSS would transition from <code>v0.65.3</code> to <code>v65.3.0</code> (in the case <code>EPOCH</code> is <code>0</code>). Following SemVer, a patch release would become <code>v65.3.1</code>, and a feature release would be <code>v65.4.0</code>. If we introduced some minor incompatible changes affecting an edge case, we could bump it to <code>v66.0.0</code> to alert users of potential impacts. In the event of a significant overhaul to the core, we could jump directly to <code>v1000.0.0</code> to signal a new era and make a big announcement. I'd suggest assigning a code name to each non-zero <code>EPOCH</code> to make it more memorable and easier to refer to. This approach provides maintainers with more flexibility to communicate the scale of changes to users effectively.</p> <blockquote> <p>[!TIP]<br> We shouldn't need to bump <code>EPOCH</code> often. It's mostly useful for high-level, end-user-facing libraries or frameworks. For low-level libraries, they might <strong>never</strong> need to bump <code>EPOCH</code> at all (<code>ZERO-EPOCH</code> is essentially the same as SemVer).</p> </blockquote> <p>Of course, I'm not suggesting that everyone should adopt this approach. It's simply an idea to work around the existing system, and only for those packages with this need. It will be interesting to see how it performs in practice.</p> <h2>Moving Forward</h2> <p>I plan to adopt Epoch Semantic Versioning in my projects, including UnoCSS, Slidev, and all the plugins I maintain, and ultimately abandon zero-major versioning for stable packages. I hope this new versioning approach will help communicate changes more effectively and provide users with better context when upgrading.</p> <p>I'd love to hear your thoughts and feedback on this idea. Feel free to share your comments using the links below!</p> ]]>
      </content:encoded>
      <author>hi@antfu.me (Anthony Fu)</author>
    </item>
    <item>
      <title>
      <![CDATA[ CPU Profiling Nuxt ]]>
      </title>
      <link>https://antfu.me/posts/nuxt-cpuprofile</link>
      <guid>https://antfu.me/posts/nuxt-cpuprofile</guid>
      <pubDate>Tue, 31 Dec 2024 16:00:00 GMT</pubDate>
      <content:encoded>
      <![CDATA[ <p>If you want to debug the bundling performance of your Nuxt app to generate CPU profiles.</p> <p>Node.js provides a built-in <a href="https://nodejs.org/api/cli.html#--cpu-prof"><code>--cpu-prof</code></a> flag that allows you to generate CPU profiles. However you can't directly pass it in your <code>nuxi</code> command, you have to use it with <code>node</code> directly.</p> <p>Instead of running <code>nuxi dev</code>, you can run <code>node</code> with the direct path to the CLI in <code>node_modules</code>:</p> <pre><code class="language-bash"># nuxi dev node --cpu-prof ./node_modules/nuxi/bin/nuxi.mjs dev --fork=false </code></pre> <p>Note that <code>--fork=false</code> is important as by <a href="https://github.com/nuxt/cli/blob/a433fbcebda8cb87d7c0c8199137877b669e1c31/src/commands/dev.ts#L69-L75">default <code>nuxi</code> will start the Nuxt process in a forked process</a> which will make the CPU profile not working.</p> <blockquote> <p>The simliar technique can be applied to other CLI tools that are not directly using <code>node</code> to start the process.</p> </blockquote> <p>After killing your Nuxt process, you will find two <code>CPU.***.cpuprofile</code> files generated in your working directory. I recommend using <a href="https://discoveryjs.github.io/cpupro/">CPUpro</a> to visualize the profile. If you are using VS Code, I also created <a href="https://marketplace.visualstudio.com/items?itemName=antfu.cpupro">an extension</a> for you to directly open the <code>.cpuprofile</code> file in VS Code easily.</p> ]]>
      </content:encoded>
      <author>hi@antfu.me (Anthony Fu)</author>
    </item>
    <item>
      <title>
      <![CDATA[ Introducing Nuxt Icon v1 ]]>
      </title>
      <link>https://antfu.me/posts/nuxt-icon-v1</link>
      <guid>https://antfu.me/posts/nuxt-icon-v1</guid>
      <pubDate>Mon, 25 Nov 2024 16:00:00 GMT</pubDate>
      <content:encoded>
      <![CDATA[ <p><a href="https://nuxt.com/blog/nuxt-icon-v1-0">Go to nuxt.com and read the full post</a>.</p> ]]>
      </content:encoded>
      <author>hi@antfu.me (Anthony Fu)</author>
    </item>
    <item>
      <title>
      <![CDATA[ Initiative on Sponsorship Forwarding ]]>
      </title>
      <link>https://antfu.me/posts/sponsorship-forwarding</link>
      <guid>https://antfu.me/posts/sponsorship-forwarding</guid>
      <pubDate>Sat, 20 Apr 2024 00:00:00 GMT</pubDate>
      <description>
      <![CDATA[ An initiative to support open-source ecosystem by Anthony Fu. ]]>
      </description>
      <content:encoded>
      <![CDATA[ <p>[[toc]]</p> <p>It's not a secret that open-source projects are now a critical part of almost every software project. While most open-source projects are maintained by volunteers, the sustainability of these projects becomes a big concern. The recent <a href="https://robmensching.com/blog/posts/2024/03/30/a-microcosm-of-the-interactions-in-open-source-projects/">xz/liblzma vulnerability</a> accident is a great example that shows the importance of open-source projects and how severe the problem could be.</p> <p>There are <a href="https://robmensching.com/blog/posts/2024/03/31/what-could-be-done-to-support-open-source-maintainers/">multiple ways to support open-source projects</a> <span op75 italic>(another excellent article by Rob Mensching, highly recommended)</span>. Funding is indeed one of its essential aspects. I believe most open-source maintainers are not doing it for money. However, maintainers still need to pay their bills to make a living and spend time maintaining the projects. Unrewarded free work is not sustainable in the long run.</p> <p>We are glad to see that more and more companies and individuals started to see the importance of open-source sustainability and have started to sponsor open-source projects. We also see that some companies have started to hire or support maintainers to work on open-sources projects full-time <span op75>(for example, thanks {NuxtLabs} for having the Nuxt core team and me 💚. {Astro} {Stackblitz} {Netlify} {Vercel} and other companies are also doing it)</span>. We, as the maintainers, genuinely appreciate all that support.</p> <p>However, today, it's still extremely hard for maintainers to figure out ways to get the minimal funds to work on open-source projects full-time, not even asking for returns that match the value they are providing. There are many aspects of open-source funding that need to be improved. In this post, I'd like to bring up some problems we have observed and propose solutions to improve the situation.</p> <h2>Unbalanced Funding</h2> <p>In open-source, there are different types of projects.</p> <p>Some projects are more &quot;front-facing&quot; and are directly interacted with by developers and users on a daily basis. These projects often have short and loud names, well-designed logos, and a large community discussing them or even holding events around them.</p> <p>On the other hand, there are also &quot;underlying&quot; dependencies that are used extensively but may not be as visible. The majority of the users may not even be aware that they are indirectly depending on them.</p> <p>Whether a project is &quot;front-facing&quot; or &quot;underlying&quot;, both types of projects are crucial to the ecosystem and deserve support. What they have in common is that they rely on people who invest their time and effort into maintaining these projects.</p> <p>Among all the contributors and maintainers, there is a mix of individuals who have different working styles and levels of visibility. Some are more &quot;high-profile&quot; and actively share their work, while others prefer to stay low-profile and focus on their contributions behind the scenes. The different working styles should not diminish the value of their work.</p> <p>Naturely, front-facing projects and high-profile maintainers are much more likely to receive attention and sponsorships, while the underlying dependencies and low-profile maintainers are often overlooked. To illustrate this, let me present you <a href="https://www.explainxkcd.com/wiki/index.php/2347:_Dependency">this famous xkcd comic</a> again:</p> <p><img src="https://antfu.me/images/oss-sponsor-dependencies.svg" alt="Open-source Sponsor Dependencies" class="dark:invert-100 dark:op80 border-none! shadow-none! max-w-120" /></p> <p>Imagine, with that critical dependency being removed, here we have a <a href="https://mastodon.social/@ahl/112243141693101752">falling apart version</a> by <a href="https://mastodon.social/@ahl">Adam Leventhal</a>:</p> <p><img src="/images/oss-sponsor-falling.svg" alt="Open-source Sponsor Dependencies" class="dark:invert-100 dark:op80 border-none! shadow-none! max-w-120" /></p> <p>When you find a tool that has been helpful to you and you want to show your support, it's natural to look for a way to sponsor the tool or its maintainers. We greatly appreciate this kind of support. The problem of the unsupported dependencies is not usually the sponsor's responsibility.</p> <p>However, it's important to recognize that when we develop a &quot;front-facing&quot; tool or framework, we often rely on other tools and dependencies to make our work possible. It wouldn't be fair for the &quot;front-facing&quot; projects to take all the credit. In reality, even those &quot;front-facing&quot; projects are often underfunded. That's why we are grateful to see many open-source projects forwarding sponsorships to supporting their dependencies.</p> <p>For example, {ESLint} <a href="https://eslint.org/blog/2022/02/paying-contributors-sponsoring-projects/">is forwarding sponsorships to its contributors and dependencies</a>, {Astro} <a href="https://astro.build/blog/astro-ecosystem-fund/">is giving funds to the ecosystem</a>, projects that I am participating like {Vite|<a href="https://opencollective.com/vite/expenses">https://opencollective.com/vite/expenses</a>} and {Elk|<a href="https://opencollective.com/elk/expenses?collectiveSlug=elk&amp;type=INVOICE">https://opencollective.com/elk/expenses?collectiveSlug=elk&amp;type=INVOICE</a>} are also started following similar approaches on their Open Collective. Many other projects are doing it as well.</p> <p>{@nzakas|Nicholas C. Zakas}, the creator of ESLint, also wrote a great article <a href="https://humanwhocodes.com/blog/2022/06/sponsoring-dependencies-open-source-sustainability/">Sponsoring dependencies: The next step in open source sustainability</a>, explaining the importance of this.</p> <h2>About Me</h2> <p>I am honestly super lucky to have the opportunity to work on numerous front-facing projects and be a relatively high-profile maintainer in the community and on social media. I am extremely grateful for <a href="https://github.com/sponsors/antfu">all the sponsorships I have received</a>. As I mentioned in <a href="https://antfu.me/posts/mental-health-oss#scope">another post</a>, I have received tremendous help from the community and contributors in creating the tools that you are using. I firmly believe that I shouldn't take all the credit and appreciation from sponsors alone. That's why I wrote this blog post - to find a way to give back to the ecosystem with the resources and influence I have.</p> <h2>Sponsorships Forwarding on GitHub</h2> <p>I am already <a href="https://github.com/antfu?tab=sponsoring">sponsoring a number of maintainers</a> who I benefit a lot from. {GitHub Sponsors|<a href="https://github.com/sponsors">https://github.com/sponsors</a>} is a great platform. It <a href="https://docs.github.com/en/sponsors/getting-started-with-github-sponsors/about-github-sponsors#about-github-sponsors">covers the transaction fees</a>, and provides great connections with sponsors, maintainers, and projects, making the discovery and sponsorship process smooth. However, while it is great for individual sponsors, it lacks the ability to forward sponsorships to other projects or maintainers. {@patak-dev} <a href="https://github.com/orgs/community/discussions/10177">raised this feature request for GitHub</a> two years ago, which is currently the top-upvoted request from the community, but unfortunately, it has not been resolved yet.</p> <p>Here, let's do some simple math to see why this feature is essential:</p> <ul> <li>With GitHub Sponsors, the maintainer receives a monthly payout to their bank account.</li> <li>This payout counts as personal income, and the maintainer needs to pay taxes based on the country they live in.</li> <li>If the maintainer wants to sponsor another maintainer, they need to pay from their own pocket.</li> <li>When the second maintainer receives the funds after another month, they must also pay taxes again.</li> </ul> <p>For example, the tax I have to pay here in France is roughly 41%. Assume both maintainers have the same tax rate. This means that when forwarding sponsorship on GitHub Sponsors, the second maintainer will only receive</p> <div text-lg text-gray:75>(1 - <span text-blue>41%</span>) x (1 - <span text-blue>41%</span>) = <span text-orange>34.81%</span></div> <p>of the original amount, plus two months of delay in between <span op75>(on top of the case that GitHub already covers the transaction fees)</span>. Sometimes, we even have circular sponsorships because we both want to show appreciation to the others. Ultimately, this is a significant loss, especially when there is not enough funding for open source already (it's also worth mentioning that GitHub Sponsors is <a href="https://docs.github.com/en/sponsors/getting-started-with-github-sponsors/about-github-sponsors#supported-regions-for-github-sponsors">not yet available in all countries</a>).</p> <p>Despite GitHub Sponsors limitations, a lot of maintainers are still forwarding part of their funds to others ({@danielroe|Danielroe's Sponsoring|<a href="https://github.com/danielroe?tab=sponsoring">https://github.com/danielroe?tab=sponsoring</a>}, {@patak-dev|Matias' Sponsoring|<a href="https://github.com/patak-dev?tab=sponsoring">https://github.com/patak-dev?tab=sponsoring</a>}, {@kazupon|Kazupon's Sponsoring|<a href="https://github.com/kazupon?tab=sponsoring">https://github.com/kazupon?tab=sponsoring</a>} and many more). While we really wanted to support more dependencies and maintainers, the current situation on GitHub is not very feasible in the long run.</p> <h2>Open Collective</h2> <p>Another popular platform for open-source projects to receive sponsorships is <a href="https://opencollective.com/">Open Collective</a>. It provides great transparency on how funds are collected and spent.</p> <p>For open-source projects, <a href="https://www.oscollective.org/">Open Source Collective</a> is a commonly used fiscal host on Open Collective. It charges a total of 10% transaction and hosting fees upfront. The important part is that it allows funds to be forwarded to other projects <strong>on the same fiscal host with no additional fees</strong>. This makes it a much better fit for the sponsorship forwarding use case.</p> <h2>Anthony Fu's Collective</h2> <p>So, I came up with the idea of creating my personal collective: {Anthony Fu Collective}</p> <p>Where you can sponsor my work across the ecosystem, including but not limited to:<br><br> {Vite} {Vue} {Nuxt} {Vitest} {VueUse} {UnoCSS} {Slidev} {Elk} {Shiki} {TwoSlash} {ESLint Stylistic}</p> <p>The main difference is that I <strong>won't take the funds for myself</strong>;<br><span op50>(except for occasional expense reimbursements like hosting or domain renewal)</span></p> <p><strong>All the funds will be redistributed to the dependencies and contributors</strong>. Each month, I will select a few dependencies and contributors to forward the funds. Depending on the amount raised, I may also set up recurring sponsorships for high-impact dependencies in the future. You give the trust and support to me, and I will make sure the funds are well spent.</p> <p><img src="/images/oss-sponsor-antfu-oc.svg" alt="Open-source Sponsor Dependencies" class="dark:invert-100 dark:op80 dark:filter-hue-rotate-180 border-none! shadow-none! max-w-120" /></p> <p>To allow differentiating easily, I will treat the funds on <a href="https://github.com/sponsors/antfu">GitHub Sponsors</a> and <a href="https://opencollective.com/antfu">Open Collective</a> differently:</p> <ul> <li>{Sponsor Anthony Fu on Open Collective|<a href="https://opencollective.com/antfu">https://opencollective.com/antfu</a>} - To sponsor the dependencies and ecosystem of the projects Anthony maintains.</li> <li>{Sponsor Anthony Fu on GitHub Sponsors|<a href="https://github.com/sponsors/antfu">https://github.com/sponsors/antfu</a>} - To sponsor Anthony's personal work on open-source projects.</li> </ul> <p>I would generally recommend sponsoring on Open Collective first to support the entire ecosystem and open source. Well, I'd also be grateful if you could sponsor on both platforms :P</p> <p>Recurring sponsorships are highly appreciated. They help provide a more consistent monthly income and contribute to long-term sustainability for the projects and maintainers.</p> <p>This collective is my approach trying to see how I can help the ecosystem with the resources and knowledge I have. It also serves as an initiative to encourage more maintainers and projects to follow, by forwarding the support they receive to the dependencies and contributors they benefit from.</p> <h2>Transparency</h2> <p>Since this involves money and trust, I think transparency is crucial here. I will try to answer honestly some questions you might have below. Feel free to raise more questions if you have any other concerns, I will try to update this post with my responses accordingly.</p> <h3>Why am I Doing this?</h3> <p>As I explained throughout this post, my intention is to contribute to the open-source ecosystem and make it better with my little efforts.</p> <p>To be completely honest and transparent, yes, I couldn't say I am not doing this 100% selflessly. Despite the fact that I am not taking funds for myself, I might still indirectly benefit from this initiative.</p> <p>I do undeniably have vanity and ego due to my human nature, and I am not ashamed to admit it. I do care about my reputation and influence to some extent. I see this endeavor as similar to contributing to open source. Does everyone do open source completely selflessly? I doubt that. But does that mean everyone is doing it solely for their own benefit? I don't believe that either. The beauty of open source lies in its non-zero-sum nature, where maintainers can derive benefits such as a sense of accomplishment, skill improvement, recognition, and reputation, while providing value to benefit the entire world.</p> <p>Being part of the open-source community who also relies on it, I certainly have the incentive to help the community become better and more sustainable. I am not a materialistic person, and the sponsorships I have received are not huge, but they are enough for me to make a basic living. While I do believe there are other projects and maintainers who would benefit more from the funds at this time.</p> <p>Ultimately, my goal is to increase the overall funding into the open-source ecosystem and develop robust systems to support projects, so that everyone can reap the benefits of open source and acknowledge the hard work put in by its contributors.</p> <h3>How to Ensure the Distribution is Fair?</h3> <p>Regrettably, I don't think it's possible to design a &quot;perfect algorithm&quot; to &quot;score&quot; and distribute the funds fairly. Representing a project, a person, or their work with a single number to rank is unrealistic.</p> <p>When it comes to equality and equity, I believe it's important to prioritize supporting underrepresented and underfunded projects and maintainers. This would involve subjective judgment, and while I can't guarantee complete fairness, I will strive to be transparent and sincere. I will actively engage with the community and openly communicate how and why the funds are distributed.</p> <h3>Why &quot;Personal&quot; Collective</h3> <p>As mentioned above, there is no absolute way to distribute the funds fairly. In this case, it's based on my judgment and the trust you give me. As the starting point of this initiative, I believe it's easier and simpler to start with a personal collective and adjust based on the feedback and results. Meanwhile, a personal collective not bound to a specific project could be more flexible and better support the goals of this initiative.</p> <p>This is certainly not going to be the only collective that forwards sponsorships. Maybe in the future, sponsoring multiple individuals collectively and group collectives would help make the distribution less opinionated and less biased.</p> <p>For a related example, inspired by <a href="https://x.com/patak_dev/status/1778020676781101313">this tweet</a>, we recently started an organization with several maintainers to improve the performance and quality across JavaScript packages. Later, we might set up a collective for this organization so you can sponsor the efforts on performance improvements. Stay tuned for a future announcement.</p> <h3>Other Alternative Platforms?</h3> <p>There are quite a few other platforms for open-source funding that also bring exciting solutions to this problem.</p> <p>This collective is only one more idea, an attempt to help our ecosystem become more sustainable - feel free to explore other platforms and initiatives you think are making sense. The main difference between this collective and the others is that it has me working behind it, instead of just metrics and algorithms. The human factor also made it possible to reduce sponsorships waterflow, where on some platforms the sub-dependencies are harder to get enough funds. With this collective, I can reach the critical dependencies and contributors directly to support them. I will spend time doing the research and communications every month to find important dependencies to support.</p> <h2>Sponsor Now</h2> <p>This initiative is something I couldn't do alone. I would need your support to make it happen.</p> <p>If I have convinced you this initiative is meaningful, use the buttons below to help me support the open-source ecosystem and make it more sustainable. Thank you!</p> <SponsorButtonCollective /> <h2>Feedback</h2> <p>I am eager to hear your feedback on this initiative. If you have any thoughts, concerns, or suggestions, please feel free to reach out to leave me a comment under <a href="https://twitter.com/antfu7/status/1781749305230885140">this tweet</a> or <a href="https://elk.zone/m.webtoo.ls/@antfu/112305352609322422">this toot</a>. You can also mail me at <a href="mailto:hi@antfu.me">hi@antfu.me</a>.</p> <p>Thank you for reading this long post. I hope we can take this initiative as a small step and make open-source better and more sustainable together. 💚</p> ]]>
      </content:encoded>
      <author>hi@antfu.me (Anthony Fu)</author>
    </item>
  </channel>
</rss>
